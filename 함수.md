## IIFE로 만들기 위해서는 어떻게 해야 하나요?

먼저 함수 정의문으로 함수를 정의하고, 선언문 바로 뒤에 소괄호로 호출문을 붙입니다.

여기서 반드시 그룹 연산자로 함수 정의문과 호출문을 묶어야 즉시실행함수로 동작할 수 있습니다.

그룹 연산자가 아니더라도 함수 리터럴이 평가되어 함수 객체를 생성할 수 있다면 다른 연산자를 사용할 수 있습니다. ( `!` , `+` )

## 클로져(Closure)는 무엇이며, 어떻게/왜 사용하는지 설명해주세요.

외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 중첩 함수는 생명 주기가 종료한 외부함수의 변수를 참조할 수 있습니다. 이러한 중첩 함수를 클로저라 부릅니다.

(반환되는 함수가 클로저이다.)

클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정됩니다.

어떻게?

즉시 실행 함수로 외부 함수를 감싸서 변수에 담고, 즉시 실행 함수 내부에서 클로저를 반환해서 사용하면 상태가 의도치 않게 변경되지 않고 유지될 수 있습니다. (수정)

- 내부 함수가 외부 함수에서 선언된 지역 변수를 참조하고 있고, 이 내부 함수가 반환되는 구조이다.

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용합니다. 특정 함수에게만 상태 변경을 허용하기 때문에 상태를 안전하게 은닉할 수 있습니다.

## this는 JavaScript에서 어떻게 작동하는지 설명해주세요.

자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값이 동적으로 결정됩니다.

일반 함수로 호출하는 경우 this는 전역 객체를 가리킵니다. (브라우저에서는 `window`, node환경에서는 `global`) this는 객체의 프로퍼티나 메서드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서는 this가 의미가 없습니다. strict 모드를 사용한 경우에는 this에 undefined가 바인딩됩니다.

객체 안의 메서드로 호출하는 경우, this는 메서드를 호출한 객체를 가리킵니다.

생성자 함수로 호출하는 경우, this는 생성자 함수가 생성할 인스턴스를 가리킵니다.

apply, call, bind 메서드로 간접 호출하는 경우, this에 바인딩할 객체를 인수에 넣어서 직접 결정할 수 있습니다.

화살표함수는 자기 자신의 this를 갖지 않아서 자신이 정의된 상위 스코프가 this 바인딩이 됩니다.

## use strict모드에서의 this는 어떻게 동작하는가?

`this`의 값이 `null`이나 `undefined`인 경우 전역 객체로 변환하지 않는다. (에러를 발생시키지 않기 위함?)

strict 모드를 사용하면, 일반 함수로 호출한 경우 this에 undefined가 바인딩됩니다.
