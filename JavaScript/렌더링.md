# 브라우저의 렌더링

## 브라우저의 렌더링 과정에 대해서 상세하게 설명해달라

**요약**

1. **필요한 리소스의 로드**

   브라우저 : 렌더링에 필요한 리소스를 요청하고 서버로부터 응답받는다.

2. **렌더 트리 생성** = DOM + CSSOM

   렌더링 엔진 : 서버로부터 응답된 HTML과 CSS를 파싱 → DOM과 CSSOM 생성 → 결합하여 렌더 트리 생성

3. **AST 생성** (자바스크립트 파싱 및 실행)

   자바스크립트 엔진 : 서버로부터 응답된 자바스크립트를 파싱하여 AST를 생성 → 바이트 코드로 변환하여 실행

   자바스크립트가 DOM API를 통해 DOM이나 CSSOM 트리를 변경한다면 : 변경된 DOM과 CSSOM이 렌더 트리로 결합 (리플로우, 리페인트)

4. **DOM 생성 재개**

   렌더링 엔진 : 자바스크립트의 파싱과 실행이 종료되면 렌더링 엔진으로 제어권이 넘어온다 → HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작해 DOM 생성을 재개한다.

**상세 설명**

1. **필요한 리소스의 로드**
   1. 렌더링에 필요한 리소스를 서버에 요청합니다.
      1. 브라우저의 주소창에 URL 입력 → URL의 호스트 이름이 DNS를 통해 IP 주소로 변환 → 이 IP 주소를 갖는 서버에 요청을 전송
      2. 루트요청 : 브라우저에 스킴과 호스트만으로 구성된 URI를 입력하면 서버는 암묵적으로 index.html을 응답합니다. (기본 설정)
      3. 루트요청 외 다른 정적 파일 : URI의 호스트 뒤의 패스에 정적 파일의 경로를 입력하여 서버에 요청 → 서버는 정적 파일의 경로에 대응하는 파일을 응답
      4. 동적 파일 : ajax, REST API
      5. 외부 리소스 로드 : CSS 파일을 로드하는 link 태그, 이미지 파일을 로드하는 img 태그, 자바스크립트를 로드하는 script 태그 를 만나면 → html의 파싱을 중단하고 리소스 파일을 서버로 요청 및 응답
   2. 서버가 리소스를 응답 → 다음 단계는 파싱 및 렌더링!
2. **렌더 트리 생성**

   1. **DOM 생성**
      1. 브라우저는 html 문서를 바이트 형태로 응답받는다.
         1. 서버에 존재하던 html 파일이 브라우저의 요청에 의해 응답
         2. 서버는 브라우저가 요청한 html 파일을 읽어들여 메모리에 저장
         3. 메모리에 저장된 바이트를 인터넷을 경유하여 응답
      2. 바이트 형태의 html 문서 → 문자열로 변환
         1. meta태그의 charset에 지정된 인코딩 방식을 기준으로 변환한다.
      3. 문자열로 변환된 html 문서를 문법적으로 쪼개서 토큰으로 분해
      4. 각 토큰을 객체로 변환하여 노드를 생성
         1. 문서 노드
         2. 요소 노드
         3. 어트리뷰트 노드
         4. 텍스트 노드
      5. html 요소 간의 부자 관계를 반영하여 모든 노드를 트리 자료구조로 구성 ⇒ DOM 생성
   2. **CSSOM 생성**

      1. 렌더링 엔진이 CSS를 로드하는 태그 (`link` , `style`) 를 만나면 DOM 생성을 일시 중단
      2. CSS 파일 파싱

         1. 서버는 css 문서들을 바이트 형태로 응답
         2. 바이트 형태의 css 문서 → 문자열로 변환
         3. 문자열로 변환된 문서를 문법적 단위인 토큰으로 분해
         4. 각 토큰을 객체로 변환하여 노드 생성
         5. CSS의 상속 관계를 반영하여 노드를 트리 자료구조로 구성

            ⇒ CSSOM 생성

      3. CSS 파싱을 완료하면 다시 html을 파싱해 DOM 생성 재개

   3. **렌더 트리 결합**
      1. 렌더링 엔진은 DOM과 CSSOM을 결합하여 렌더 트리를 생성한다. (브라우저 화면에 렌더링되는 노드만으로 구성)
   4. **layout** : 렌더 트리는 html 요소의 레이아웃 계산
   5. **paint** : 브라우저 화면에 픽셀을 렌더링하는 페인팅 처리에 입력
      - 리페인팅 : 리플로우로 인해 재결합된 렌더 트리를 기반으로 다시 페인트를 한다.

3. **자바스크립트 파싱과 실행**
   1. 렌더링 엔진은 DOM을 생성하다가 script 태그를 만나면 DOM 생성을 일시 중단한다.
      1. script 태그 내부에 작성된 자바스크립트 코드
         1. src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 응답받은 자바스크립트 코드
         2. 인라인으로 작성된 자바스크립트 코드
   2. **자바스크립트 엔진은 자바스크립트 코드를 파싱하고 실행한다.**
      1. 토크나이징 : 단순한 문자열인 자바스크립트 소스코드 → 문법적 의미를 갖는 토큰으로 분해
      2. 파싱 : 토큰들의 집합을 구문 분석하여 AST 생성
      3. 바이트 코드 : 생성된 AST를 인터프리터가 실행할 수 있는 바이트 코드로 변환 → 인터프리터가 실행
   3. **리렌더링 :** 자바스크립트가 DOM API를 이용해서 DOM, CSSOM을 변경하면
      - 리플로우 : 레이아웃에 영향을 주는 변경이 발생하면 레이아웃 계산을 다시 한다.
        1. 노드의 추가, 삭제
        2. 요소의 크기, 위치 변경
        3. 윈도우의 리사이징
4. 자바스크립트의 파싱과 실행이 종료되면 렌더링 엔진으로 제어권을 넘겨 **DOM 생성을 재개**한다.

## HTML이 렌더링 중에 Javascript가 실행되면 렌더링이 멈추는데 그 이유는 무엇인가

브라우저는 동기적으로 html, css, js를 파싱하고 실행합니다. 브라우저의 렌더링 엔진이 html을 파싱하면서 DOM을 생성하다가 script 태그를 만나면 DOM 생성이 중단되고, 자바스크립트 엔진에 코드 제어권이 넘어가서 자바스크립트를 파싱하고 실행합니다. 따라서 script 태그의 위치에 따라 html 파싱이 블로킹되어 js가 먼저 실행될 수 있습니다.

이 때의 자바스크립트 코드에서 DOM API를 사용할 때 DOM의 생성이 완료되지 않은 경우 에러가 발생할 수 있습니다.

body 요소 가장 아래에 script 태그를 위치시키거나, script 태그에 async, defer 어트리뷰트를 지정해 자바스크립트 파일을 비동기적으로 동시에 진행시키면 이 문제를 해결할 수 있습니다.
